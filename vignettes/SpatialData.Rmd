---
title: "The `SpatialData` class"
date: "`r format(Sys.Date(), '%B %d, %Y')`"
package: "`r BiocStyle::pkg_ver('SpatialData')`"
author:
- name: Constantin Ahlmann-Eltze
  affiliation: EMBL Genome Biology Unit, Heidelberg, Germany
- name: Helena L Crowell
  affiliation:
  - Department of Molecular Life Sciences, University of Zurich, Switzerland
  - SIB Swiss Institute of Bioinformatics, University of Zurich, Switzerland
- name: Tim Treis
  affiliation: Computational Health Center, Helmholtz Center Munich, Neuherberg, Germany
output: 
  BiocStyle::html_document:
    toc: true
    toc-depth: 2
    toc-float: true
# having some bug & this gets around it
knit: (function(input, ...) rmarkdown::render(input, output_dir=".")) 
vignette: >
  %\VignetteIndexEntry{"foo"}
  %\VignettePackage{foo}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
#bibliography: "`r file.path(system.file('extdata', package='muscat'), 'refs.bib')`"
abstract: > 
  <p> ...
---

```{r setup, inclue=FALSE}
knitr::opts_chunk$set(cache=TRUE)
```

# Preamble

## Dependencies

```{r load-libs, message=FALSE, warning=FALSE}
library(Rarr)
library(EBImage)
library(ggplot2)
library(jsonlite)
library(patchwork)
library(SpatialData)
library(SingleCellExperiment)
```

```{r}
# utility for image plotting with 'EBImage'
.plot <- \(i) {
    c <- ifelse(
        length(dim(i)) == 3, 
        "Color", "Grayscale")
    j <- as.array(aperm(i))
    plot(Image(j/max(j), dim(j), c))
}
```

## Introduction

# `SpatialData`

The `SpatialData` class contains 5 elements that are represented as follows:

- `images`: list of `ImageArray`s
- `labels`: list of `LabelArray`s
- `shapes`: list of `ShapeFrame`s
- `points`: list of Arrow `Dataset`s
- `table`: a `SingleCellExperiment`

```{r}
path <- system.file("extdata", "blobs", package="SpatialData", mustWork=TRUE)
(spd <- readSpatialData(path))
```

## Accession

The following accessors are currently supported:

- `image/label/shape/pointNames` to retrieve available entities of the respective element.
- `images/labels/shapes/points` to retrieve a list of entities of the respective element.
- `image/label/shape/point` to retrieve a single entity of the respective element.
- `$` to directly access the entities of the respective element.

`SpatialData` objects behave like a list, i.e., entities of a all
elements can be accessed in various (equivalent) ways:

```{r results="hide"}
# these are all equivalent
i <- "blobs_image"
element(spd, "images", i)
images(spd)[[i]]
image(spd, i)
spd$images[[i]]
```

# `ZarrArray`

The `ZarrArray` class is essentially an `Annotated` array-like object, that may
contain a dense `array` or any type of `Array` (e.g., `Sparse/DelayedArray`).
Derived here-from are the `ImageArray` and `LabelArray` classes
that represent single entities of `images` and `labels`, respectively.
These differ slightly in their associated metadata
and array properties, but share many functions.

```{r}
# construction
zarr <- file.path(path, "images", "blobs_image")
(ia <- readArray(zarr))
```

# Transformations

Only translation, scaling, and rotation of `Image/LabelArray`s are currently supported
via the following functions, each of which expects a \code{SpatialData} object (SD),
as well as transformation data `t` according to:

- `rotateElement`: scalar integer (angle).
- `scaleElement`: numeric vector with as many elements as SD has dimensions.
- `translateElement`: integer vector of length 2 (row/y and col/x translation).

```{r}
(i <- image(spd))
# view available channels
channels(i)
```

Available coordinate systems can be retrieved via `coords()`:

- `type`: type of transformation (one of identity, rotate, scale, ...)
- `data`: transformation data (`NA` when `type = "identity"`)
- `output.name` the target coordinate system's identity

```{r}
coords(i)
```

## scale

```{r}
j <- scaleElement(i, c(1,1,2))
par(mfrow=c(1,2)); .plot(i); .plot(j)
```

## rotate

```{r}
j <- rotateElement(i, 30)
par(mfrow=c(1,2)); .plot(i); .plot(j)
```

# Visualization

`plotSD` currently supports overlaying up to 3 elements 
(an image, label and shape, but not points yet).
Argument `coord` specifies the target coordinate system,
and will default the first available shared one if left unspecified.
Elements are internally aligned via `alignElements`,
which in turn calls `transformArray` on the input
`image` and `label` (type `Image/LabelArray`).
Depending on the underlying metadata, `transformArray`
uses `scale/rotate/translateArray` for transformation.

```{r}
path <- system.file("extdata", "raccoon", package="SpatialData", mustWork=TRUE)
(spd <- readSpatialData(path))
```

```{r}
# clockwise rotation about the origin
ps <- lapply(c(0, 90, 180), \(angle) 
    rotateElement(shape(spd), angle))
wrap_plots(lapply(ps, plotElement))
```

```{r}
plotElement(image(spd)) +
plotElement(label(spd)) +
plotElement(shape(spd)) 
```

```{r}
plotSD(spd,
    image="raccoon",
    label="segmentation",
    shape="circles",
    alpha.label=1/3,
    alpha.shape=1,
    fill.shape="lightgrey")
```

# Query

`aggregateImage` computed aggregated measurement values from `image`
according to `label` using `fun` to summarized measurements (default `mean`).
By default, the first available `image` and `label` are used.
In the output `SingleCellExperiment`, rows correspond
to channels and columns to unique labels (excluding 0); 
aggregated xy-coordinates are included in the `colData`.

```{r}
(sce <- aggregateImage(spd))
```

# Appendix

## Session info

```{r session-info}
sessionInfo()
```
